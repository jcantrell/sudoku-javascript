<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    * { padding: 0; margin: 0; }
    canvas { background: #fff; display: block; margin: 0 auto; }
  </style>
</head>
<body>
  <canvas id="mainCanvas" width="480" height="320"></canvas>
<script> 
class Point { 
  constructor(x=0,y=0) {
    this.x=x;
    this.y=y;
  }
  asString() {
    return "(Pt "+x+" "+y+")";
  }
}
class Line {
  constructor (a, b) {
    this.a = a;
    this.b = b;
  }
  draw (ctx) {
    ctx.beginPath();
    ctx.strokeStyle = 'blue';
    ctx.lineWidth = 1;
    ctx.moveTo(this.a.x,this.a.y);
    ctx.lineTo(this.b.x,this.b.y);
    ctx.stroke();
  }
  asString() {
    return "(Line: "+this.a.asString()+" "+this.b.asString()+")"
  }
}
class Sudoku {
  constructor(xin=0,yin=0) {
    this.board = [
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0]
    ];
    this.inked = [
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0]
    ];
    this.focus = { x: 0, y: 0, r: 0, c: 0 };
    this.tl = new Point(xin,yin);
    this.bw = 50;
    this.bh = 50;
    this.debug = true;
  }
  inkedasString() {
    var s="";
    for (var r=0;r<9;r++) { 
      for (var c=0;c<9;c++) {
        s+=this.inked[r][c]+" ";
      }
      s+="\n";
    }
    s+="Valid: "+this.isValid(this.board)+" isFull: "+this.isFull(this.board)
      +"\n";
    return s;
  }
  asString() {
    var s="";
    for (var r=0;r<9;r++) { 
      for (var c=0;c<9;c++) {
        s+=this.board[r][c]+" ";
      }
      s+="\n";
    }
    s+="Valid: "+this.isValid(this.board)+" isFull: "+this.isFull(this.board)
      +"\n";
    return s;
  }
  copy() {
    var ret = new Sudoku();
    for (var r=0;r<9;r++) for (var c=0; c<9; c++) {
      ret.board[r][c] = this.board[r][c];
      ret.inked[r][c] = this.inked[r][c];
    }
    ret.focus.x = this.focus.x; ret.focus.y = this.focus.y; ret.focus.r = this.focus.r; ret.focus.c = this.focus.c;
    ret.tl.x = this.tl.x; ret.tl.y = this.tl.y;
    ret.bw = this.bw;
    ret.bh = this.bh;
    return ret;
  }
  copyFrom(i) {
    for (var r=0;r<9;r++) for (var c=0; c<9; c++) 
      this.board[r][c] = i.board[r][c];
  }
  copyBoard(bin) {
    var b = [
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0]
    ];
    for (var r=0;r<9;r++) for (var c=0; c<9; c++) b[r][c] = bin[r][c];
    return b;
  }
  draw (ctx) {
    this.tl.x = ctx.canvas.getBoundingClientRect().left;
    this.tl.y = ctx.canvas.getBoundingClientRect().top;

    // Background
    ctx.fillStyle = "lightgrey";
    ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
    
    // Highlight focused row and column
    for (var i=0;i<9;i++) {
      ctx.fillStyle = "#bbbbbb";
      ctx.fillRect(i*this.bw,this.focus.r*this.bh,this.bw,this.bh);
      ctx.fillRect(this.focus.c*this.bw,i*this.bh,this.bw,this.bh);
    }

    // Highlight focused square
    ctx.fillStyle = "#cccccc";
    ctx.fillRect(this.focus.c*this.bw,this.focus.r*this.bh,this.bw,this.bh);

    // Outline individual squares
    for (var r=0;r<9;r++) {
      for (var c=0;c<9;c++) {
        ctx.strokeStyle = 'grey';
        ctx.strokeRect(c*this.bw, r*this.bh, this.bw, this.bh);
      }
    }

    // Draw 3x3 outlined squares
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    for (var r=0;r<3;r++) {
      for (var c=0;c<3;c++) {
        ctx.strokeRect(c*this.bw*3, r*this.bh*3, this.bw*3, this.bh*3);
      }
    }
    ctx.lineWidth = 1;

    // Print numbers
    for (var r=0;r<9;r++) {
      for (var c=0;c<9;c++) {
        ctx.fillStyle = 'black';
        ctx.font = '16px serif';
        if (this.board[r][c] != 0)
          ctx.fillText(this.board[r][c],(c+1)*this.bw-30,(r+1)*this.bh-20);
      }
    }
  }
  click(ctx,e) {
    ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
    this.focus.x = e.x - this.tl.x; 
    this.focus.y = e.y - this.tl.y;
    this.focus.r = Math.floor(this.focus.y / this.bh);
    this.focus.c = Math.floor(this.focus.x / this.bw);
    this.draw(ctx);
  }
  ink(x,y,v) {
    this.board[x][y] = v;
    this.inked[x][y] = 1;
  }
  next(xin,yin) {
    xin = (xin+1)%9;
    if (xin==0)
      yin = (yin+1)%9;
    return { x: xin, y: yin }
  }
  prev(xin,yin) {
    xin = xin-1;
    if (xin<0) {
      xin = 8;
      yin--;
      if (yin<0)
        yin=8;
    }
    return { x: xin, y: yin }
  }
  nextUninked(xin,yin) {
    var s = this.next(xin,yin);
    while (this.inked[s.y][s.x] == 1)
      s = this.next(s.x,s.y);
    return s;
  }
  prevUninked(xin,yin) {
    var s = this.prev(xin,yin);
    while (this.inked[s.y][s.x] == 1)
      s = this.prev(s.x,s.y);
    return s;
  }
  firstUninked() {
    var s = { x: 0, y: 0 };
    if (this.inked[s.y][s.x]==0) return s;
    else return this.nextUninked(s.x,s.y);
  }
  lastUninked() {
    var s = { x: 8, y: 8 };
    if (this.inked[s.y][s.x]==0) return s;
    else return this.prevUninked(s.x,s.y);
  }
  setupsolve() {
    this.count = 0;
    this.overflow = false;
    this.m = {x:0,y:0};
    this.s = this.firstUninked();
  }
  solve () {
    if (this.isValid() && this.isFull()) return true;
    // Find first penciled square
/*
    var s = b.firstUninked();
    
    var count = 0;
    var overflow = false;
    var m = {x:0,y:0};
*/

    var drawflag = true;

    var s = this.s;
    var count = this.count;
    this.db("Count: "+count);
    var m = this.m;
    var overflow = this.overflow;
    while(true && count < 10000) {
    this.db("Hello");
      if (drawflag) {
      this.db("loopS: "+s.x+" "+s.y+" "+this.board[s.y][s.x]+" "+this.inked[s.y][s.x]+" overflow: "+overflow);
      this.db("Count: "+count);
      this.db("Max: "+m.x+m.y+this.board[m.x][m.y]);
      this.db(this.asString());
        //drawflag = false;
      }
      count++;
      if (overflow) {
        if (drawflag) this.db("overflow "+s.x+" "+s.y);
        overflow = false;
        if (s.x == this.firstUninked().x && s.y == this.firstUninked().y) {
          if (drawflag) this.db("Solution not found");
          return false;
        } else {
          s = this.prevUninked(s.x,s.y);
        }
        this.board[s.y][s.x] = (this.board[s.y][s.x]+1)%10;
        if (this.board[s.y][s.x]==0) overflow = true;
      } else if (!this.isValid()) { 
        if (drawflag) this.db("was invalid");
        this.board[s.y][s.x] = (this.board[s.y][s.x]+1)%10;
        if (this.board[s.y][s.x]==0) overflow = true;
      } else if (this.board[s.y][s.x] == 0) {
        if (drawflag) this.db("was blank");
        this.board[s.y][s.x] = (this.board[s.y][s.x]+1)%10;
        if (this.board[s.y][s.x]==0) overflow = true;
      } else {
        if (drawflag) this.db("not blank"+" "+s.x+" "+s.y);
        if (s.x==this.lastUninked().x && s.y==this.lastUninked().y) {
          if (drawflag) this.db("Solution found");
          return true;
        } else {
          s = this.nextUninked(s.x,s.y);
        }
      }
      
      if (s.y > m.y) {
        m.x = s.x; m.y = s.y; drawflag=true;
      } else if (s.y == m.y && s.x > m.x) {
        m.x = s.x; m.y = s.y; drawflag=true;
      }
      this.db("\n");
    }
/*
      this.db(b.asString());
      this.db("Count: "+count);
      count--;
      if (b.board[s.y][s.x]==0) b.board[s.y][s.x]++;
      if (b.isValid()) {
        if (s.x==9 && s.y==9) return true;
        else {
          s.x = (s.x+1) % 9; if (s.x==0) s.y = (s.y+1) % 9;
          while (b.inked[s.y][s.x] == 1) {
            s.x = (s.x+1) % 9; if (s.x==0) s.y = (s.y+1) % 9;
          }
        }
      } else {
        if (b.board[s.y][s.x]!=9) b.board[s.y][s.x]++;
        else {
          if (s.x==0 && s.y==0) return false;
          else {
            while (b.board[s.y][s.x]==9) {
              b.board[s.y][s.x]=0;
              if ( !(s.x==0 && s.y==0) ) {
                s = this.prevUninked(s.x,s.y);
              } else {
                return false;
              }
            }
            b.board[s.y][s.x] = (b.board[s.y][s.x]+1)%10;
          }
        }
      }
    }
*/
/*
    if (!b.isValid()) return false;
    if (b.isFull()) 
    {
      this.db("SOLUTION FOUND!\n");
      this.db(b.asString());
      this.db("XXXXXXXXXXXXXX!\n");
      return true;
    }
    // Find first penciled square
    var s = {x: 0, y: 0};
    for (s.x=0;s.x<9 && b.board[s.x][s.y] != 0;s.x++) {
      for (s.y=0;s.y<9 && b.board[s.x][s.y] != 0;s.y++)
        ;
    s.x--;s.y--;
    //this.db("Fist blank: "+s.x+" "+s.y+" "+b.board[s.x][s.y]+"\n");
    for (var v=1;v<=9;v++) {
      b.board[s.x][s.y] = v;
      if (this.solve(b))
        return true; 
    }
    this.db("solve failed\n");
    return false;
*/
  }
  db(text) {
    if (this.debug) console.log(text);
  }
  keypress(ctx,e) {
    if (e.keyCode >= 48 && e.keyCode <= 57) {
      this.board[this.focus.r][this.focus.c] = e.keyCode - 48;
      this.draw(ctx);
      this.isValid(this.board);
    } else if (e.keyCode == 83) {
      var t = this.copy();
      //this.solve(t);
      t.setupsolve();
      t.solve();
      this.copyFrom(t);
      console.log(this.asString()+"\n");
      this.draw(ctx);
    }
  }
  isValid(b = this.board) {
    var totals = [
      [
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0]
      ],
      [
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0]
      ],
      [
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0]
      ]
    ];
    for (var r=0;r<9;r++) {
      for (var c=0;c<9;c++) {
        if (this.board[r][c] != 0) {
          totals[0][r][b[r][c]-1]++;
          totals[1][c][b[r][c]-1]++;
          totals[2][Math.floor(r/3)*3+Math.floor(c/3)][b[r][c]-1]++;
        }
      }
    }
    var flag=true;
    for (var i=0;i<3;i++) {
      for (var r=0;r<9;r++) {
        for (var c=0;c<9;c++) {
          flag = flag && !(totals[i][r][c] > 1);
        }
      }
    }
    return flag;
  }
  isFull(b = this.board) {
    var flag = true;
    for (var r=0;r<9;r++)
      for (var c=0;c<9;c++)
        flag = flag && (b[r][c] != 0);
    return flag;
  }
  fromString(s) {
    // ll is linelength in chars
    var x=0, y=0, nl=0;
    // Map string indexes (into current line) to board x-values
    //            1,  3,  5,      9,  11, 13,     17, 19, 21
    var xmap = [x,0,x,1,x,2,x,x,x,3,x,4,x,5,x,x,x,6,x,7,x,8,x];
    for (let i=0;i < s.length; i++) {
      if (s[i] === '\n') nl = i+1, y = (s[i+1]==='-') ? y : y+1;
      if (s[i] ==='.') this.board[xmap[y][i-nl]] = 0;
      if (s[i] >= '0' && s[i] <= '9') this.board[y][xmap[i-nl]] = (s[i] - '0');
    }
  }
}

var canvas = document.getElementById("mainCanvas");
var ctx = canvas.getContext('2d');
let sudoku = new Sudoku(ctx.canvas.getBoundingClientRect().left,ctx.canvas.getBoundingClientRect().top);

board1 = "\
 9 5 . | . . . | 6 . 3\n\
 1 . . | 7 . . | 5 . .\n\
 . . 8 | 2 . . | . . .\n\
-------+-------+-------\n\
 . . . | . 1 . | . . 9\n\
 7 . 1 | 8 . 3 | 2 . 6\n\
 2 . . | . 4 . | . . .\n\
-------+-------+-------\n\
 . . . | . . 1 | 8 . .\n\
 . . 2 | . . 6 | . . 5\n\
 5 . 4 | . . . | . 9 7\n";

board2 = "\
 5 . 9 | . . . | . . 3\n\
 1 . . | . . 9 | . 8 2\n\
 . 7 . | . 8 5 | 9 4 .\n\
-------+-------+-------\n\
 . 2 . | 8 3 . | 7 . .\n\
 . . 8 | . . . | 3 . .\n\
 . . 7 | . 9 1 | . 2 .\n\
-------+-------+-------\n\
 . 6 2 | 1 5 . | . 9 .\n\
 9 4 . | 6 . . | . . 7\n\
 8 . . | . . . | 2 . 5\n";

board3 = "\
 . 8 . | 2 1 4 | 6 7 .\n\
 . 3 4 | 7 6 . | 5 . .\n\
 2 . 6 | 3 . . | . . 1\n\
-------+-------+-------\n\
 4 . 1 | . . 6 | . 5 9\n\
 . . . | . . . | . . .\n\
 . . . | . . . | . . .\n\
-------+-------+-------\n\
 . . . | . . . | . . .\n\
 . . . | . . . | . . .\n\
 . . . | . . . | . . .\n";

sudoku.fromString(board2);

var canvas = document.getElementById("mainCanvas");
document.addEventListener("mousedown", mouseDownHandler);
document.addEventListener("keydown", keyDownHandler);
document.addEventListener("mousemove", mouseMoveHandler);
canvas.width = 450;
canvas.height = 450;
sudoku.draw(ctx);
function mouseDownHandler(e) {
  var x = e.x - sudoku.tl.x;
  var y = e.y - sudoku.tl.y;
  if ((x <= canvas.width) && (y <= canvas.height) && x >= 0 && y >= 0)
    sudoku.click(ctx,e);
}
function keyDownHandler(e) {
  sudoku.keypress(ctx,e);
}
function mouseMoveHandler(e) {
  if (e.x <= canvas.width && e.y <= canvas.height)
    sudoku.keypress(ctx,e);
}
</script>
</body>
</html>
