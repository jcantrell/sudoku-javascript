<!DOCTYPE html>
<html>
<head>
  <style>
    * { padding: 0; margin: 0; }
    canvas { background: #fff; display: block; margin: 0 auto; }
  </style>
</head>
<body>
  <canvas id="mainCanvas" width="480" height="320"></canvas>
<script> class Point { constructor(x=0,y=0) {
    this.x=x;
    this.y=y;
  }
}
class Line {
  constructor (a, b) {
    this.a = a;
    this.b = b;
  }
  draw (ctx) {
    ctx.beginPath();
    ctx.strokeStyle = 'blue';
    ctx.lineWidth = 1;
    ctx.moveTo(this.a.x,this.a.y);
    ctx.lineTo(this.b.x,this.b.y);
    ctx.stroke();
  }
}
class SudokuGrid {
  constructor (
  )
  {
  }
}
class Sudoku {
  constructor(xin=0,yin=0) {
    this.board = [
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0]
    ];
    this.focus = { x: 0, y: 0, r: 0, c: 0 };
    this.tl = new Point(xin,yin);
    this.bw = 50;
    this.bh = 50;
  }
  copy() {
    var ret = new Sudoku();
    for (var r=0;r<9;r++) for (var c=0; c<9; c++) ret.board[r][c] = this.board[r][c];
    ret.focus.x = this.focus.x; ret.focus.y = this.focus.y; ret.focus.r = this.focus.r; ret.focus.c = this.focus.c;
    ret.tl.x = this.tl.x; ret.tl.y = this.tl.y;
    ret.bw = this.bw;
    ret.bh = this.bh;
    return ret;
  }
  copyBoard(bin) {
    //alert("begin copy");
    var b = [
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0]
    ];
    //alert("before loop");
    for (var r=0;r<9;r++) for (var c=0; c<9; c++) b[r][c] = bin[r][c];
    //alert("after loop");
    return b;
  }
  draw (ctx) {

    // Background
    ctx.fillStyle = "lightgrey";
    ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
    
    // Highlight focused row and column
    for (var i=0;i<9;i++) {
      ctx.fillStyle = "#bbbbbb";
      ctx.fillRect(i*this.bw,this.focus.r*this.bh,this.bw,this.bh);
      ctx.fillRect(this.focus.c*this.bw,i*this.bh,this.bw,this.bh);
    }

    // Highlight focused square
    ctx.fillStyle = "#cccccc";
    ctx.fillRect(this.focus.c*this.bw,this.focus.r*this.bh,this.bw,this.bh);

    // Outline individual squares
    for (var r=0;r<9;r++) {
      for (var c=0;c<9;c++) {
        ctx.strokeStyle = 'grey';
        ctx.strokeRect(c*this.bw, r*this.bh, this.bw, this.bh);
      }
    }

    // Draw 3x3 outlined squares
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    for (var r=0;r<3;r++) {
      for (var c=0;c<3;c++) {
        ctx.strokeRect(c*this.bw*3, r*this.bh*3, this.bw*3, this.bh*3);
      }
    }
    ctx.lineWidth = 1;

    // Print numbers
    for (var r=0;r<9;r++) {
      for (var c=0;c<9;c++) {
        ctx.fillStyle = 'black';
        ctx.font = '16px serif';
        //alert("printing numbers");
        if (this.board[r][c] != 0)
          ctx.fillText(this.board[r][c],(c+1)*this.bw-30,(r+1)*this.bh-20);
      }
    }
  }
  click(ctx,e) {
    ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
    this.focus.x = e.x - this.tl.x; 
    this.focus.y = e.y - this.tl.y;
    this.focus.r = Math.floor(this.focus.y / this.bh);
    this.focus.c = Math.floor(this.focus.x / this.bw);
    this.draw(ctx);
  }
  solve (b,ctx) {
    //alert("solve called");
    for (var r=0;r<9;r++) {
      //alert("first loop");
      for (var c=0;c<9;c++) {
        //alert("second loop "+c);
        if (b[r][c] == 0) {
          //alert("b[r][c]: "+b[r][c]);
          for (var v=1;v<=9;v++) {
            //alert("v: "+v);
            b[r][c] = v;
            //alert("assigned");
            //this.draw(ctx);
            //alert("drawn");
            if (this.isValid(this.copyBoard(b))) {
              //alert("valid: "+r+" "+c+" "+v);
              if (this.isFull(this.copyBoard(b))) { 
                alert("final solution found");

                for (var i=0;i<9;i++) for (var j=0;j<9;j++)
                  this.board[i][j] = b[r][c];

                return true; 
              } else {
                if (this.solve(this.copyBoard(b))) {
                  return true;
                }
              }
            } else { alert("not valid"); }
          }
        }
      }
    }
    alert("solve failed");
    return false;
  }
  keypress(ctx,e) {
    if (e.keyCode >= 48 && e.keyCode <= 57) {
      this.board[this.focus.r][this.focus.c] = e.keyCode - 48;
      this.draw(ctx);
      this.isValid(this.board);
    } else if (e.keyCode == 83) {
      var t = this.copyBoard(this.board);
      //alert("calling solve");
      this.solve(t,ctx);
      this.draw(ctx);
      //alert("solve called");
    }
  }
  isValid(b) {
    var totals = [
      [
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0]
      ],
      [
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0]
      ],
      [
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0]
      ]
    ];
    for (var r=0;r<9;r++) {
      for (var c=0;c<9;c++) {
        if (this.board[r][c] != 0) {
          totals[0][r][b[r][c]-1]++;
          totals[1][c][b[r][c]-1]++;
          totals[2][Math.floor(r/3)*3+Math.floor(c/3)][b[r][c]-1]++;
        }
      }
    }
    var flag=true;
    for (var i=0;i<3;i++) {
      for (var r=0;r<9;r++) {
        for (var c=0;c<9;c++) {
          flag = flag && !(totals[i][r][c] > 1);
        }
      }
    }
    return flag;
  }
  isFull(b) {
    //alert("isFull called");
    var flag = true;
    for (var r=0;r<9;r++)
      for (var c=0;c<9;c++)
        flag = flag && (b[r][c] != 0);
    //alert("isFull returning with "+flag);
    return flag;
  }
}

var canvas = document.getElementById("mainCanvas");
var ctx = canvas.getContext('2d');
let sudoku = new Sudoku(ctx.canvas.getBoundingClientRect().left,ctx.canvas.getBoundingClientRect().top);
sudoku.board[0][0] = 5;
sudoku.board[0][2] = 9;
sudoku.board[0][8] = 3;
sudoku.board[1][0] = 1;
sudoku.board[1][5] = 9;
sudoku.board[1][7] = 8;
sudoku.board[1][8] = 2;
sudoku.board[2][1] = 7;
sudoku.board[2][4] = 8;
sudoku.board[2][5] = 5;
sudoku.board[2][6] = 9;
sudoku.board[2][7] = 4;
sudoku.board[3][1] = 2;
sudoku.board[3][3] = 8;
sudoku.board[3][4] = 3;
sudoku.board[3][6] = 7;
sudoku.board[4][2] = 8;
sudoku.board[4][6] = 3;
sudoku.board[5][2] = 7;
sudoku.board[5][4] = 9;
sudoku.board[5][5] = 1;
sudoku.board[5][7] = 2;
sudoku.board[6][1] = 6;
sudoku.board[6][2] = 2;
sudoku.board[6][3] = 1;
sudoku.board[6][4] = 5;
sudoku.board[6][7] = 9;
sudoku.board[7][0] = 9;
sudoku.board[7][1] = 4;
sudoku.board[7][3] = 6;
sudoku.board[7][8] = 7;
sudoku.board[8][0] = 8;
sudoku.board[8][6] = 2;
sudoku.board[8][8] = 5;
document.addEventListener("mousedown", mouseDownHandler);
document.addEventListener("keydown", keyDownHandler);
document.addEventListener("mousemove", mouseMoveHandler);
canvas.width = 450;
canvas.height = 450;
//ctx.fillStyle = "lightgrey";
//ctx.fillRect(0,0,canvas.width,canvas.height);
sudoku.draw(ctx);
function mouseDownHandler(e) {
  var x = e.x - sudoku.tl.x;
  var y = e.y - sudoku.tl.y;
  if ((x <= canvas.width) && (y <= canvas.height) && x >= 0 && y >= 0)
    sudoku.click(ctx,e);
}
function keyDownHandler(e) {
  sudoku.keypress(ctx,e);
}
function mouseMoveHandler(e) {
  if (e.x <= canvas.width && e.y <= canvas.height)
    sudoku.keypress(ctx,e);
}
</script>
</body>
</html>
